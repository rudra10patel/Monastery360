{
  "version": 3,
  "sources": ["../../../node_modules/@radix-ui/primitive/src/primitive.tsx", "../../../node_modules/@radix-ui/react-context/src/create-context.tsx", "../../../node_modules/@radix-ui/react-primitive/src/primitive.tsx", "../../../node_modules/@radix-ui/react-dismissable-layer/src/dismissable-layer.tsx", "../../../node_modules/@radix-ui/react-use-callback-ref/src/use-callback-ref.tsx", "../../../node_modules/@radix-ui/react-use-escape-keydown/src/use-escape-keydown.tsx", "../../../node_modules/@radix-ui/react-portal/src/portal.tsx", "../../../node_modules/@radix-ui/react-use-layout-effect/src/use-layout-effect.tsx", "../../../node_modules/@radix-ui/react-presence/src/presence.tsx", "../../../node_modules/@radix-ui/react-presence/src/use-state-machine.tsx", "../../../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state.tsx", "../../../node_modules/@radix-ui/react-use-controllable-state/src/use-controllable-state-reducer.tsx", "../../../node_modules/@radix-ui/react-id/src/id.tsx"],
  "sourcesContent": ["function composeEventHandlers<E extends { defaultPrevented: boolean }>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n", "import * as React from 'react';\n\nfunction createContext<ContextValueType extends object | null>(\n  rootComponentName: string,\n  defaultContext?: ContextValueType\n) {\n  const Context = React.createContext<ContextValueType | undefined>(defaultContext);\n\n  const Provider: React.FC<ContextValueType & { children: React.ReactNode }> = (props) => {\n    const { children, ...context } = props;\n    // Only re-memoize when prop values change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  };\n\n  Provider.displayName = rootComponentName + 'Provider';\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== undefined) return defaultContext;\n    // if a defaultContext wasn't specified, it's a required context.\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n\n  return [Provider, useContext] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * createContextScope\n * -----------------------------------------------------------------------------------------------*/\n\ntype Scope<C = any> = { [scopeName: string]: React.Context<C>[] } | undefined;\ntype ScopeHook = (scope: Scope) => { [__scopeProp: string]: Scope };\ninterface CreateScope {\n  scopeName: string;\n  (): ScopeHook;\n}\n\nfunction createContextScope(scopeName: string, createContextScopeDeps: CreateScope[] = []) {\n  let defaultContexts: any[] = [];\n\n  /* -----------------------------------------------------------------------------------------------\n   * createContext\n   * ---------------------------------------------------------------------------------------------*/\n\n  function createContext<ContextValueType extends object | null>(\n    rootComponentName: string,\n    defaultContext?: ContextValueType\n  ) {\n    const BaseContext = React.createContext<ContextValueType | undefined>(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n\n    const Provider: React.FC<\n      ContextValueType & { scope: Scope<ContextValueType>; children: React.ReactNode }\n    > = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      // Only re-memoize when prop values change\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      const value = React.useMemo(() => context, Object.values(context)) as ContextValueType;\n      return <Context.Provider value={value}>{children}</Context.Provider>;\n    };\n\n    Provider.displayName = rootComponentName + 'Provider';\n\n    function useContext(consumerName: string, scope: Scope<ContextValueType | undefined>) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== undefined) return defaultContext;\n      // if a defaultContext wasn't specified, it's a required context.\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n\n    return [Provider, useContext] as const;\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * createScope\n   * ---------------------------------------------------------------------------------------------*/\n\n  const createScope: CreateScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope: Scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n\n  createScope.scopeName = scopeName;\n  return [createContext, composeContextScopes(createScope, ...createContextScopeDeps)] as const;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * composeContextScopes\n * -----------------------------------------------------------------------------------------------*/\n\nfunction composeContextScopes(...scopes: CreateScope[]) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n\n  const createScope: CreateScope = () => {\n    const scopeHooks = scopes.map((createScope) => ({\n      useScope: createScope(),\n      scopeName: createScope.scopeName,\n    }));\n\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {\n        // We are calling a hook inside a callback which React warns against to avoid inconsistent\n        // renders, however, scoping doesn't have render side effects so we ignore the rule.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes, ...currentScope };\n      }, {});\n\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nexport { createContext, createContextScope };\nexport type { CreateScope, Scope };\n", "import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { createSlot } from '@radix-ui/react-slot';\n\nconst NODES = [\n  'a',\n  'button',\n  'div',\n  'form',\n  'h2',\n  'h3',\n  'img',\n  'input',\n  'label',\n  'li',\n  'nav',\n  'ol',\n  'p',\n  'select',\n  'span',\n  'svg',\n  'ul',\n] as const;\n\ntype Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };\ntype PrimitivePropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E> & {\n  asChild?: boolean;\n};\n\ninterface PrimitiveForwardRefComponent<E extends React.ElementType>\n  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp: any = asChild ? Slot : node;\n\n    if (typeof window !== 'undefined') {\n      (window as any)[Symbol.for('radix-ui')] = true;\n    }\n\n    return <Comp {...primitiveProps} ref={forwardedRef} />;\n  });\n\n  Node.displayName = `Primitive.${node}`;\n\n  return { ...primitive, [node]: Node };\n}, {} as Primitives);\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Flush custom event dispatch\n * https://github.com/radix-ui/primitives/pull/1378\n *\n * React batches *all* event handlers since version 18, this introduces certain considerations when using custom event types.\n *\n * Internally, React prioritises events in the following order:\n *  - discrete\n *  - continuous\n *  - default\n *\n * https://github.com/facebook/react/blob/a8a4742f1c54493df00da648a3f9d26e3db9c8b5/packages/react-dom/src/events/ReactDOMEventListener.js#L294-L350\n *\n * `discrete` is an  important distinction as updates within these events are applied immediately.\n * React however, is not able to infer the priority of custom event types due to how they are detected internally.\n * Because of this, it's possible for updates from custom events to be unexpectedly batched when\n * dispatched by another `discrete` event.\n *\n * In order to ensure that updates from custom events are applied predictably, we need to manually flush the batch.\n * This utility should be used when dispatching a custom event from within another `discrete` event, this utility\n * is not necessary when dispatching known event types, or if dispatching a custom type inside a non-discrete event.\n * For example:\n *\n * dispatching a known click \uD83D\uDC4E\n * target.dispatchEvent(new Event(\u2018click\u2019))\n *\n * dispatching a custom type within a non-discrete event \uD83D\uDC4E\n * onScroll={(event) => event.target.dispatchEvent(new CustomEvent(\u2018customType\u2019))}\n *\n * dispatching a custom type within a `discrete` event \uD83D\uDC4D\n * onPointerDown={(event) => dispatchDiscreteCustomEvent(event.target, new CustomEvent(\u2018customType\u2019))}\n *\n * Note: though React classifies `focus`, `focusin` and `focusout` events as `discrete`, it's  not recommended to use\n * this utility with them. This is because it's possible for those handlers to be called implicitly during render\n * e.g. when focus is within a component as it is unmounted, or when managing focus on mount.\n */\n\nfunction dispatchDiscreteCustomEvent<E extends CustomEvent>(target: E['target'], event: E) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n  //\n  dispatchDiscreteCustomEvent,\n};\nexport type { PrimitivePropsWithRef };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled!); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ComponentRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n", "import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nexport { useCallbackRef };\n", "import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\n/**\n * Listens for when the escape key is down\n */\nfunction useEscapeKeydown(\n  onEscapeKeyDownProp?: (event: KeyboardEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        onEscapeKeyDown(event);\n      }\n    };\n    ownerDocument.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => ownerDocument.removeEventListener('keydown', handleKeyDown, { capture: true });\n  }, [onEscapeKeyDown, ownerDocument]);\n}\n\nexport { useEscapeKeydown };\n", "import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  /**\n   * An optional container where the portaled content should be appended.\n   */\n  container?: Element | DocumentFragment | null;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { container: containerProp, ...portalProps } = props;\n  const [mounted, setMounted] = React.useState(false);\n  useLayoutEffect(() => setMounted(true), []);\n  const container = containerProp || (mounted && globalThis?.document?.body);\n  return container\n    ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n    : null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  //\n  Root,\n};\nexport type { PortalProps };\n", "import * as React from 'react';\n\n/**\n * On the server, React emits a warning when calling `useLayoutEffect`.\n * This is because neither `useLayoutEffect` nor `useEffect` run on the server.\n * We use this safe version which suppresses the warning by replacing it with a noop on the server.\n *\n * See: https://reactjs.org/docs/hooks-reference.html#uselayouteffect\n */\nconst useLayoutEffect = globalThis?.document ? React.useLayoutEffect : () => {};\n\nexport { useLayoutEffect };\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './use-state-machine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration | null>(null);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      stylesRef.current = node ? getComputedStyle(node) : null;\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles: CSSStyleDeclaration | null) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Presence;\n\nexport {\n  Presence,\n  //\n  Root,\n};\nexport type { PresenceProps };\n", "import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// \uD83E\uDD2F https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// Prevent bundlers from trying to optimize the import\nconst useInsertionEffect: typeof useLayoutEffect =\n  (React as any)[' useInsertionEffect '.trim().toString()] || useLayoutEffect;\n\ntype ChangeHandler<T> = (state: T) => void;\ntype SetStateFn<T> = React.Dispatch<React.SetStateAction<T>>;\n\ninterface UseControllableStateParams<T> {\n  prop?: T | undefined;\n  defaultProp: T;\n  onChange?: ChangeHandler<T>;\n  caller?: string;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n  caller,\n}: UseControllableStateParams<T>): [T, SetStateFn<T>] {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(prop !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  const setValue = React.useCallback<SetStateFn<T>>(\n    (nextValue) => {\n      if (isControlled) {\n        const value = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value !== prop) {\n          onChangeRef.current?.(value);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n\n  return [value, setValue];\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>): [\n  Value: T,\n  setValue: React.Dispatch<React.SetStateAction<T>>,\n  OnChangeRef: React.RefObject<ChangeHandler<T> | undefined>,\n] {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n\n  return [value, setValue, onChangeRef];\n}\n\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "import * as React from 'react';\nimport { useEffectEvent } from '@radix-ui/react-use-effect-event';\n\ntype ChangeHandler<T> = (state: T) => void;\n\ninterface UseControllableStateParams<T> {\n  prop: T | undefined;\n  defaultProp: T;\n  onChange: ChangeHandler<T> | undefined;\n  caller: string;\n}\n\ninterface AnyAction {\n  type: string;\n}\n\nconst SYNC_STATE = Symbol('RADIX:SYNC_STATE');\n\ninterface SyncStateAction<T> {\n  type: typeof SYNC_STATE;\n  state: T;\n}\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialState: S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, I, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: I,\n  init: (i: I & { state: T }) => S\n): [S & { state: T }, React.Dispatch<A>];\n\nexport function useControllableStateReducer<T, S extends {}, A extends AnyAction>(\n  reducer: (prevState: S & { state: T }, action: A) => S & { state: T },\n  userArgs: UseControllableStateParams<T>,\n  initialArg: any,\n  init?: (i: any) => Omit<S, 'state'>\n): [S & { state: T }, React.Dispatch<A>] {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== undefined;\n\n  const onChange = useEffectEvent(onChangeProp);\n\n  // OK to disable conditionally calling hooks here because they will always run\n  // consistently in the same environment. Bundlers should be able to remove the\n  // code block entirely in production.\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (process.env.NODE_ENV !== 'production') {\n    const isControlledRef = React.useRef(controlledState !== undefined);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? 'controlled' : 'uncontrolled';\n        const to = isControlled ? 'controlled' : 'uncontrolled';\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  /* eslint-enable react-hooks/rules-of-hooks */\n\n  type InternalState = S & { state: T };\n  const args: [InternalState] = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    // @ts-expect-error\n    args.push(init);\n  }\n\n  const [internalState, dispatch] = React.useReducer(\n    (state: InternalState, action: A | SyncStateAction<T>): InternalState => {\n      if (action.type === SYNC_STATE) {\n        return { ...state, state: action.state };\n      }\n\n      const next = reducer(state, action);\n      if (isControlled && !Object.is(next.state, state.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React.useRef(uncontrolledState);\n  React.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n\n  const state = React.useMemo(() => {\n    const isControlled = controlledState !== undefined;\n    if (isControlled) {\n      return { ...internalState, state: controlledState };\n    }\n\n    return internalState;\n  }, [internalState, controlledState]);\n\n  React.useEffect(() => {\n    // Sync internal state for controlled components so that reducer is called\n    // with the correct state values\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n\n  return [state, dispatch as React.Dispatch<A>];\n}\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n// We spaces with `.trim().toString()` to prevent bundlers from trying to `import { useId } from 'react';`\nconst useReactId = (React as any)[' useId '.trim().toString()] || (() => undefined);\nlet count = 0;\n\nfunction useId(deterministicId?: string): string {\n  const [id, setId] = React.useState<string | undefined>(useReactId());\n  // React versions older than 18 will have client-side ids only.\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : '');\n}\n\nexport { useId };\n"],
  "mappings": "sIAAA,SAASA,EACPC,EACAC,EACA,CAAE,yBAAAC,EAA2B,EAAK,EAAI,CAAC,EACvC,CACA,OAAO,SAAqBC,EAAU,CAGpC,GAFAH,GAAA,MAAAA,EAAuBG,GAEnBD,IAA6B,IAAS,CAACC,EAAM,iBAC/C,OAAOF,GAAA,YAAAA,EAAkBE,EAE7B,CACF,CCZA,IAAAC,EAAuB,SAaZC,EAAA,SAXX,SAASC,GACPC,EACAC,EACA,CACA,IAAMC,EAAgB,gBAA4CD,CAAc,EAE1EE,EAAwEC,GAAU,CACtF,GAAM,CAAE,SAAAC,EAAU,GAAGC,CAAQ,EAAIF,EAG3BG,EAAc,UAAQ,IAAMD,EAAS,OAAO,OAAOA,CAAO,CAAC,EACjE,SAAO,OAACJ,EAAQ,SAAR,CAAiB,MAAAK,EAAe,SAAAF,CAAA,CAAS,CACnD,EAEAF,EAAS,YAAcH,EAAoB,WAE3C,SAASQ,EAAWC,EAAsB,CACxC,IAAMH,EAAgB,aAAWJ,CAAO,EACxC,GAAII,EAAS,OAAOA,EACpB,GAAIL,IAAmB,OAAW,OAAOA,EAEzC,MAAM,IAAI,MAAM,KAAKQ,CAAY,4BAA4BT,CAAiB,IAAI,CACpF,CAEA,MAAO,CAACG,EAAUK,CAAU,CAC9B,CAaA,SAASE,GAAmBC,EAAmBC,EAAwC,CAAC,EAAG,CACzF,IAAIC,EAAyB,CAAC,EAM9B,SAASd,EACPC,EACAC,EACA,CACA,IAAMa,EAAoB,gBAA4Cb,CAAc,EAC9Ec,EAAQF,EAAgB,OAC9BA,EAAkB,CAAC,GAAGA,EAAiBZ,CAAc,EAErD,IAAME,EAEDC,GAAU,OACb,GAAM,CAAE,MAAAY,EAAO,SAAAX,EAAU,GAAGC,CAAQ,EAAIF,EAClCF,IAAUe,EAAAD,GAAA,YAAAA,EAAQL,KAAR,YAAAM,EAAqBF,KAAUD,EAGzCP,EAAc,UAAQ,IAAMD,EAAS,OAAO,OAAOA,CAAO,CAAC,EACjE,SAAO,OAACJ,EAAQ,SAAR,CAAiB,MAAAK,EAAe,SAAAF,CAAA,CAAS,CACnD,EAEAF,EAAS,YAAcH,EAAoB,WAE3C,SAASQ,EAAWC,EAAsBO,EAA4C,OACpF,IAAMd,IAAUe,EAAAD,GAAA,YAAAA,EAAQL,KAAR,YAAAM,EAAqBF,KAAUD,EACzCR,EAAgB,aAAWJ,CAAO,EACxC,GAAII,EAAS,OAAOA,EACpB,GAAIL,IAAmB,OAAW,OAAOA,EAEzC,MAAM,IAAI,MAAM,KAAKQ,CAAY,4BAA4BT,CAAiB,IAAI,CACpF,CAEA,MAAO,CAACG,EAAUK,CAAU,CAC9B,CAMA,IAAMU,EAA2B,IAAM,CACrC,IAAMC,EAAgBN,EAAgB,IAAKZ,GAC5B,gBAAcA,CAAc,CAC1C,EACD,OAAO,SAAkBe,EAAc,CACrC,IAAMI,GAAWJ,GAAA,YAAAA,EAAQL,KAAcQ,EACvC,OAAa,UACX,KAAO,CAAE,CAAC,UAAUR,CAAS,EAAE,EAAG,CAAE,GAAGK,EAAO,CAACL,CAAS,EAAGS,CAAS,CAAE,GACtE,CAACJ,EAAOI,CAAQ,CAClB,CACF,CACF,EAEA,OAAAF,EAAY,UAAYP,EACjB,CAACZ,EAAesB,GAAqBH,EAAa,GAAGN,CAAsB,CAAC,CACrF,CAMA,SAASS,MAAwBC,EAAuB,CACtD,IAAMC,EAAYD,EAAO,CAAC,EAC1B,GAAIA,EAAO,SAAW,EAAG,OAAOC,EAEhC,IAAML,EAA2B,IAAM,CACrC,IAAMM,EAAaF,EAAO,IAAKJ,IAAiB,CAC9C,SAAUA,EAAY,EACtB,UAAWA,EAAY,SACzB,EAAE,EAEF,OAAO,SAA2BO,EAAgB,CAChD,IAAMC,EAAaF,EAAW,OAAO,CAACE,EAAY,CAAE,SAAAC,EAAU,UAAAhB,CAAU,IAAM,CAK5E,IAAMiB,EADaD,EAASF,CAAc,EACV,UAAUd,CAAS,EAAE,EACrD,MAAO,CAAE,GAAGe,EAAY,GAAGE,CAAa,CAC1C,EAAG,CAAC,CAAC,EAEL,OAAa,UAAQ,KAAO,CAAE,CAAC,UAAUL,EAAU,SAAS,EAAE,EAAGG,CAAW,GAAI,CAACA,CAAU,CAAC,CAC9F,CACF,EAEA,OAAAR,EAAY,UAAYK,EAAU,UAC3BL,CACT,CCnIA,IAAAW,EAAuB,SACvBC,EAA0B,SA6Cf,IAAAC,EAAA,SA1CLC,GAAQ,CACZ,IACA,SACA,MACA,OACA,KACA,KACA,MACA,QACA,QACA,KACA,MACA,KACA,IACA,SACA,OACA,MACA,IACF,EAcMC,EAAYD,GAAM,OAAO,CAACE,EAAWC,IAAS,CAClD,IAAMC,EAAOC,EAAW,aAAaF,CAAI,EAAE,EACrCG,EAAa,aAAW,CAACC,EAA2CC,IAAsB,CAC9F,GAAM,CAAE,QAAAC,EAAS,GAAGC,CAAe,EAAIH,EACjCI,EAAYF,EAAUL,EAAOD,EAEnC,OAAI,OAAO,QAAW,cACnB,OAAe,OAAO,IAAI,UAAU,CAAC,EAAI,OAGrC,OAACQ,EAAA,CAAM,GAAGD,EAAgB,IAAKF,CAAA,CAAc,CACtD,CAAC,EAED,OAAAF,EAAK,YAAc,aAAaH,CAAI,GAE7B,CAAE,GAAGD,EAAW,CAACC,CAAI,EAAGG,CAAK,CACtC,EAAG,CAAC,CAAe,EA2CnB,SAASM,EAAmDC,EAAqBC,EAAU,CACrFD,GAAiB,YAAU,IAAMA,EAAO,cAAcC,CAAK,CAAC,CAClE,CCjGA,IAAAC,EAAuB,SCAvB,IAAAC,EAAuB,SAMvB,SAASC,EAAkDC,EAA4B,CACrF,IAAMC,EAAoB,SAAOD,CAAQ,EAEnC,OAAA,YAAU,IAAM,CACpBC,EAAY,QAAUD,CACxB,CAAC,EAGY,UAAQ,IAAO,IAAIE,IAAA,OAAS,OAAAC,EAAAF,EAAY,UAAZ,YAAAE,EAAA,KAAAF,EAAsB,GAAGC,IAAa,CAAC,CAAC,CACnF,CCfA,IAAAE,EAAuB,SAMvB,SAASC,EACPC,EACAC,EAA0B,mCAAY,SACtC,CACA,IAAMC,EAAkBC,EAAeH,CAAmB,EAEpD,YAAU,IAAM,CACpB,IAAMI,EAAiBC,GAAyB,CAC1CA,EAAM,MAAQ,UAChBH,EAAgBG,CAAK,CAEzB,EACA,OAAAJ,EAAc,iBAAiB,UAAWG,EAAe,CAAE,QAAS,EAAK,CAAC,EACnE,IAAMH,EAAc,oBAAoB,UAAWG,EAAe,CAAE,QAAS,EAAK,CAAC,CAC5F,EAAG,CAACF,EAAiBD,CAAa,CAAC,CACrC,CFqIM,IAAAK,EAAA,SA/IAC,GAAyB,mBACzBC,EAAiB,0BACjBC,GAAuB,sCACvBC,GAAgB,gCAElBC,GAEEC,GAAgC,gBAAc,CAClD,OAAQ,IAAI,IACZ,uCAAwC,IAAI,IAC5C,SAAU,IAAI,GAChB,CAAC,EAsCKC,GAAyB,aAC7B,CAACC,EAAOC,IAAiB,OACvB,GAAM,CACJ,4BAAAC,EAA8B,GAC9B,gBAAAC,EACA,qBAAAC,EACA,eAAAC,EACA,kBAAAC,EACA,UAAAC,EACA,GAAGC,CACL,EAAIR,EACES,EAAgB,aAAWX,EAAuB,EAClD,CAACY,EAAMC,CAAO,EAAU,WAAyC,IAAI,EACrEC,GAAgBC,EAAAH,GAAA,YAAAA,EAAM,gBAAN,KAAAG,EAAuB,mCAAY,SACnD,CAAC,CAAEC,CAAK,EAAU,WAAS,CAAC,CAAC,EAC7BC,EAAeC,EAAgBf,EAAeS,GAASC,EAAQD,CAAI,CAAC,EACpEO,EAAS,MAAM,KAAKR,EAAQ,MAAM,EAClC,CAACS,CAA4C,EAAI,CAAC,GAAGT,EAAQ,sCAAsC,EAAE,MAAM,EAAE,EAC7GU,EAAoDF,EAAO,QAAQC,CAA6C,EAChHE,EAAQV,EAAOO,EAAO,QAAQP,CAAI,EAAI,GACtCW,GAA8BZ,EAAQ,uCAAuC,KAAO,EACpFa,EAAyBF,GAASD,EAElCI,GAAqBC,GAAuBC,GAAU,CAC1D,IAAMC,EAASD,EAAM,OACfE,EAAwB,CAAC,GAAGlB,EAAQ,QAAQ,EAAE,KAAMmB,GAAWA,EAAO,SAASF,CAAM,CAAC,EACxF,CAACJ,GAA0BK,IAC/BvB,GAAA,MAAAA,EAAuBqB,GACvBnB,GAAA,MAAAA,EAAoBmB,GACfA,EAAM,kBAAkBlB,GAAA,MAAAA,IAC/B,EAAGK,CAAa,EAEViB,EAAeC,GAAiBL,GAAU,CAC9C,IAAMC,EAASD,EAAM,OACG,CAAC,GAAGhB,EAAQ,QAAQ,EAAE,KAAMmB,GAAWA,EAAO,SAASF,CAAM,CAAC,IAEtFrB,GAAA,MAAAA,EAAiBoB,GACjBnB,GAAA,MAAAA,EAAoBmB,GACfA,EAAM,kBAAkBlB,GAAA,MAAAA,IAC/B,EAAGK,CAAa,EAEhB,OAAAmB,EAAkBN,GAAU,CACHL,IAAUX,EAAQ,OAAO,KAAO,IAEvDN,GAAA,MAAAA,EAAkBsB,GACd,CAACA,EAAM,kBAAoBlB,IAC7BkB,EAAM,eAAe,EACrBlB,EAAU,GAEd,EAAGK,CAAa,EAEV,YAAU,IAAM,CACpB,GAAKF,EACL,OAAIR,IACEO,EAAQ,uCAAuC,OAAS,IAC1DZ,GAA4Be,EAAc,KAAK,MAAM,cACrDA,EAAc,KAAK,MAAM,cAAgB,QAE3CH,EAAQ,uCAAuC,IAAIC,CAAI,GAEzDD,EAAQ,OAAO,IAAIC,CAAI,EACvBsB,GAAe,EACR,IAAM,CAET9B,GACAO,EAAQ,uCAAuC,OAAS,IAExDG,EAAc,KAAK,MAAM,cAAgBf,GAE7C,CACF,EAAG,CAACa,EAAME,EAAeV,EAA6BO,CAAO,CAAC,EAQxD,YAAU,IACP,IAAM,CACNC,IACLD,EAAQ,OAAO,OAAOC,CAAI,EAC1BD,EAAQ,uCAAuC,OAAOC,CAAI,EAC1DsB,GAAe,EACjB,EACC,CAACtB,EAAMD,CAAO,CAAC,EAEZ,YAAU,IAAM,CACpB,IAAMwB,EAAe,IAAMnB,EAAM,CAAC,CAAC,EACnC,gBAAS,iBAAiBpB,EAAgBuC,CAAY,EAC/C,IAAM,SAAS,oBAAoBvC,EAAgBuC,CAAY,CACxE,EAAG,CAAC,CAAC,KAGH,OAACC,EAAU,IAAV,CACE,GAAG1B,EACJ,IAAKO,EACL,MAAO,CACL,cAAeM,GACXC,EACE,OACA,OACF,OACJ,GAAGtB,EAAM,KACX,EACA,eAAgBmC,EAAqBnC,EAAM,eAAgB6B,EAAa,cAAc,EACtF,cAAeM,EAAqBnC,EAAM,cAAe6B,EAAa,aAAa,EACnF,qBAAsBM,EACpBnC,EAAM,qBACNuB,GAAmB,oBACrB,CAAA,CACF,CAEJ,CACF,EAEAxB,GAAiB,YAAcN,GAM/B,IAAM2C,GAAc,yBAKdC,GAA+B,aAGnC,CAACrC,EAAOC,IAAiB,CACzB,IAAMQ,EAAgB,aAAWX,EAAuB,EAClDwC,EAAY,SAAsC,IAAI,EACtDvB,EAAeC,EAAgBf,EAAcqC,CAAG,EAEhD,OAAA,YAAU,IAAM,CACpB,IAAM5B,EAAO4B,EAAI,QACjB,GAAI5B,EACF,OAAAD,EAAQ,SAAS,IAAIC,CAAI,EAClB,IAAM,CACXD,EAAQ,SAAS,OAAOC,CAAI,CAC9B,CAEJ,EAAG,CAACD,EAAQ,QAAQ,CAAC,KAEd,OAACyB,EAAU,IAAV,CAAe,GAAGlC,EAAO,IAAKe,CAAA,CAAc,CACtD,CAAC,EAEDsB,GAAuB,YAAcD,GAYrC,SAASZ,GACPpB,EACAQ,EAA0B,mCAAY,SACtC,CACA,IAAM2B,EAA2BC,EAAepC,CAAoB,EAC9DqC,EAAoC,SAAO,EAAK,EAChDC,EAAuB,SAAO,IAAM,CAAC,CAAC,EAEtC,OAAA,YAAU,IAAM,CACpB,IAAMC,EAAqBlB,GAAwB,CACjD,GAAIA,EAAM,QAAU,CAACgB,EAA4B,QAAS,CAGxD,IAASG,EAAT,UAAoD,CAClDC,GACElD,GACA4C,EACAO,EACA,CAAE,SAAU,EAAK,CACnB,CACF,EAPS,IAAAF,EAAAA,EAFT,IAAME,EAAc,CAAE,cAAerB,CAAM,EAuBvCA,EAAM,cAAgB,SACxBb,EAAc,oBAAoB,QAAS8B,EAAe,OAAO,EACjEA,EAAe,QAAUE,EACzBhC,EAAc,iBAAiB,QAAS8B,EAAe,QAAS,CAAE,KAAM,EAAK,CAAC,GAE9EE,EAAyC,CAE7C,MAGEhC,EAAc,oBAAoB,QAAS8B,EAAe,OAAO,EAEnED,EAA4B,QAAU,EACxC,EAcMM,EAAU,OAAO,WAAW,IAAM,CACtCnC,EAAc,iBAAiB,cAAe+B,CAAiB,CACjE,EAAG,CAAC,EACJ,MAAO,IAAM,CACX,OAAO,aAAaI,CAAO,EAC3BnC,EAAc,oBAAoB,cAAe+B,CAAiB,EAClE/B,EAAc,oBAAoB,QAAS8B,EAAe,OAAO,CACnE,CACF,EAAG,CAAC9B,EAAe2B,CAAwB,CAAC,EAErC,CAEL,qBAAsB,IAAOE,EAA4B,QAAU,EACrE,CACF,CAMA,SAASX,GACPzB,EACAO,EAA0B,mCAAY,SACtC,CACA,IAAMoC,EAAqBR,EAAenC,CAAc,EAClD4C,EAAkC,SAAO,EAAK,EAE9C,OAAA,YAAU,IAAM,CACpB,IAAMC,EAAezB,GAAsB,CACrCA,EAAM,QAAU,CAACwB,EAA0B,SAE7CJ,GAA6BjD,GAAeoD,EADxB,CAAE,cAAevB,CAAM,EACkC,CAC3E,SAAU,EACZ,CAAC,CAEL,EACA,OAAAb,EAAc,iBAAiB,UAAWsC,CAAW,EAC9C,IAAMtC,EAAc,oBAAoB,UAAWsC,CAAW,CACvE,EAAG,CAACtC,EAAeoC,CAAkB,CAAC,EAE/B,CACL,eAAgB,IAAOC,EAA0B,QAAU,GAC3D,cAAe,IAAOA,EAA0B,QAAU,EAC5D,CACF,CAEA,SAASjB,IAAiB,CACxB,IAAMP,EAAQ,IAAI,YAAY/B,CAAc,EAC5C,SAAS,cAAc+B,CAAK,CAC9B,CAEA,SAASoB,GACPM,EACAC,EACAC,EACA,CAAE,SAAAC,CAAS,EACX,CACA,IAAM5B,EAAS2B,EAAO,cAAc,OAC9B5B,EAAQ,IAAI,YAAY0B,EAAM,CAAE,QAAS,GAAO,WAAY,GAAM,OAAAE,CAAO,CAAC,EAC5ED,GAAS1B,EAAO,iBAAiByB,EAAMC,EAA0B,CAAE,KAAM,EAAK,CAAC,EAE/EE,EACFC,EAA4B7B,EAAQD,CAAK,EAEzCC,EAAO,cAAcD,CAAK,CAE9B,CAEA,IAAM+B,GAAOzD,GACP0D,GAASpB,GG9Vf,IAAAqB,EAAuB,SACvBC,GAAqB,SCDrB,IAAAC,GAAuB,SASjBC,EAAkB,6BAAY,SAAiB,mBAAkB,IAAM,CAAC,EDiBlD,IAAAC,GAAA,SAjBtBC,GAAc,SAWdC,GAAe,aAAuC,CAACC,EAAOC,IAAiB,OACnF,GAAM,CAAE,UAAWC,EAAe,GAAGC,CAAY,EAAIH,EAC/C,CAACI,EAASC,CAAU,EAAU,WAAS,EAAK,EAClDC,EAAgB,IAAMD,EAAW,EAAI,EAAG,CAAC,CAAC,EAC1C,IAAME,EAAYL,GAAkBE,KAAWI,EAAA,mCAAY,WAAZ,YAAAA,EAAsB,MACrE,OAAOD,EACH,GAAAE,QAAS,gBAAa,QAACC,EAAU,IAAV,CAAe,GAAGP,EAAa,IAAKF,CAAA,CAAc,EAAIM,CAAS,EACtF,IACN,CAAC,EAEDR,GAAO,YAAcD,GE9BrB,IAAAa,EAAuB,SCAvB,IAAAC,GAAuB,SAWhB,SAASC,GACdC,EACAC,EACA,CACA,OAAa,cAAW,CAACC,EAAwBC,IAA4C,CAC3F,IAAMC,EAAaH,EAAQC,CAAK,EAAUC,CAAK,EAC/C,OAAOC,GAAA,KAAAA,EAAaF,CACtB,EAAGF,CAAY,CACjB,CDTA,IAAMK,GAAqCC,GAAU,CACnD,GAAM,CAAE,QAAAC,EAAS,SAAAC,CAAS,EAAIF,EACxBG,EAAWC,GAAYH,CAAO,EAE9BI,EACJ,OAAOH,GAAa,WAChBA,EAAS,CAAE,QAASC,EAAS,SAAU,CAAC,EAClC,WAAS,KAAKD,CAAQ,EAG5BI,EAAMC,EAAgBJ,EAAS,IAAKK,GAAcH,CAAK,CAAC,EAE9D,OADmB,OAAOH,GAAa,YAClBC,EAAS,UAAkB,eAAaE,EAAO,CAAE,IAAAC,CAAI,CAAC,EAAI,IACjF,EAEAP,GAAS,YAAc,WAMvB,SAASK,GAAYH,EAAkB,CACrC,GAAM,CAACQ,EAAMC,CAAO,EAAU,WAAsB,EAC9CC,EAAkB,SAAmC,IAAI,EACzDC,EAAuB,SAAOX,CAAO,EACrCY,EAA6B,SAAe,MAAM,EAClDnB,EAAeO,EAAU,UAAY,YACrC,CAACL,EAAOkB,CAAI,EAAIrB,GAAgBC,EAAc,CAClD,QAAS,CACP,QAAS,YACT,cAAe,kBACjB,EACA,iBAAkB,CAChB,MAAO,UACP,cAAe,WACjB,EACA,UAAW,CACT,MAAO,SACT,CACF,CAAC,EAEK,OAAA,YAAU,IAAM,CACpB,IAAMqB,EAAuBC,EAAiBL,EAAU,OAAO,EAC/DE,EAAqB,QAAUjB,IAAU,UAAYmB,EAAuB,MAC9E,EAAG,CAACnB,CAAK,CAAC,EAEVqB,EAAgB,IAAM,CACpB,IAAMC,EAASP,EAAU,QACnBQ,EAAaP,EAAe,QAGlC,GAF0BO,IAAelB,EAElB,CACrB,IAAMmB,EAAoBP,EAAqB,QACzCE,EAAuBC,EAAiBE,CAAM,EAEhDjB,EACFa,EAAK,OAAO,EACHC,IAAyB,SAAUG,GAAA,YAAAA,EAAQ,WAAY,OAGhEJ,EAAK,SAAS,EAWZA,EADEK,GAFgBC,IAAsBL,EAGnC,gBAEA,SAFe,EAMxBH,EAAe,QAAUX,CAC3B,CACF,EAAG,CAACA,EAASa,CAAI,CAAC,EAElBG,EAAgB,IAAM,OACpB,GAAIR,EAAM,CACR,IAAIY,EACEC,GAAcC,EAAAd,EAAK,cAAc,cAAnB,KAAAc,EAAkC,OAMhDC,EAAsB3B,GAA0B,CAEpD,IAAM4B,EADuBT,EAAiBL,EAAU,OAAO,EACf,SAASd,EAAM,aAAa,EAC5E,GAAIA,EAAM,SAAWY,GAAQgB,IAW3BX,EAAK,eAAe,EAChB,CAACF,EAAe,SAAS,CAC3B,IAAMc,EAAkBjB,EAAK,MAAM,kBACnCA,EAAK,MAAM,kBAAoB,WAK/BY,EAAYC,EAAY,WAAW,IAAM,CACnCb,EAAK,MAAM,oBAAsB,aACnCA,EAAK,MAAM,kBAAoBiB,EAEnC,CAAC,CACH,CAEJ,EACMC,EAAwB9B,GAA0B,CAClDA,EAAM,SAAWY,IAEnBI,EAAqB,QAAUG,EAAiBL,EAAU,OAAO,EAErE,EACA,OAAAF,EAAK,iBAAiB,iBAAkBkB,CAAoB,EAC5DlB,EAAK,iBAAiB,kBAAmBe,CAAkB,EAC3Df,EAAK,iBAAiB,eAAgBe,CAAkB,EACjD,IAAM,CACXF,EAAY,aAAaD,CAAS,EAClCZ,EAAK,oBAAoB,iBAAkBkB,CAAoB,EAC/DlB,EAAK,oBAAoB,kBAAmBe,CAAkB,EAC9Df,EAAK,oBAAoB,eAAgBe,CAAkB,CAC7D,CACF,MAGEV,EAAK,eAAe,CAExB,EAAG,CAACL,EAAMK,CAAI,CAAC,EAER,CACL,UAAW,CAAC,UAAW,kBAAkB,EAAE,SAASlB,CAAK,EACzD,IAAW,cAAaa,GAAsB,CAC5CE,EAAU,QAAUF,EAAO,iBAAiBA,CAAI,EAAI,KACpDC,EAAQD,CAAI,CACd,EAAG,CAAC,CAAC,CACP,CACF,CAIA,SAASO,EAAiBE,EAAoC,CAC5D,OAAOA,GAAA,YAAAA,EAAQ,gBAAiB,MAClC,CAOA,SAASV,GAAcoB,EAA2D,SAEhF,IAAIC,GAASN,EAAA,OAAO,yBAAyBK,EAAQ,MAAO,KAAK,IAApD,YAAAL,EAAuD,IAChEO,EAAUD,GAAU,mBAAoBA,GAAUA,EAAO,eAC7D,OAAIC,EACMF,EAAgB,KAI1BC,GAASE,EAAA,OAAO,yBAAyBH,EAAS,KAAK,IAA9C,YAAAG,EAAiD,IAC1DD,EAAUD,GAAU,mBAAoBA,GAAUA,EAAO,eACrDC,EACKF,EAAQ,MAAM,IAIhBA,EAAQ,MAAM,KAAQA,EAAgB,IAC/C,CE7LA,IAAAI,EAAuB,SCAvB,IAAAC,EAAuB,SDIvB,IAAMC,GACHC,EAAc,uBAAuB,KAAK,EAAE,SAAS,CAAC,GAAKC,EAYvD,SAASC,GAAwB,CACtC,KAAAC,EACA,YAAAC,EACA,SAAAC,EAAW,IAAM,CAAC,EAClB,OAAAC,CACF,EAAsD,CACpD,GAAM,CAACC,EAAkBC,EAAqBC,CAAW,EAAIC,GAAqB,CAChF,YAAAN,EACA,SAAAC,CACF,CAAC,EACKM,EAAeR,IAAS,OACxBS,EAAQD,EAAeR,EAAOI,EAMO,CACzC,IAAMM,EAAwB,SAAOV,IAAS,MAAS,EACjD,YAAU,IAAM,CACpB,IAAMW,EAAgBD,EAAgB,QAClCC,IAAkBH,GAGpB,QAAQ,KACN,GAAGL,CAAM,qBAHEQ,EAAgB,aAAe,cAGR,OAFzBH,EAAe,aAAe,cAEI,4KAC7C,EAEFE,EAAgB,QAAUF,CAC5B,EAAG,CAACA,EAAcL,CAAM,CAAC,CAC3B,CAGA,IAAMS,EAAiB,cACpBC,GAAc,OACb,GAAIL,EAAc,CAChB,IAAMC,EAAQK,GAAWD,CAAS,EAAIA,EAAUb,CAAI,EAAIa,EACpDJ,IAAUT,KACZe,EAAAT,EAAY,UAAZ,MAAAS,EAAA,KAAAT,EAAsBG,GAE1B,MACEJ,EAAoBQ,CAAS,CAEjC,EACA,CAACL,EAAcR,EAAMK,EAAqBC,CAAW,CACvD,EAEA,MAAO,CAACG,EAAOG,CAAQ,CACzB,CAEA,SAASL,GAAwB,CAC/B,YAAAN,EACA,SAAAC,CACF,EAIE,CACA,GAAM,CAACO,EAAOG,CAAQ,EAAU,WAASX,CAAW,EAC9Ce,EAAqB,SAAOP,CAAK,EAEjCH,EAAoB,SAAOJ,CAAQ,EACzC,OAAAN,GAAmB,IAAM,CACvBU,EAAY,QAAUJ,CACxB,EAAG,CAACA,CAAQ,CAAC,EAEP,YAAU,IAAM,OAChBc,EAAa,UAAYP,KAC3BM,EAAAT,EAAY,UAAZ,MAAAS,EAAA,KAAAT,EAAsBG,GACtBO,EAAa,QAAUP,EAE3B,EAAG,CAACA,EAAOO,CAAY,CAAC,EAEjB,CAACP,EAAOG,EAAUN,CAAW,CACtC,CAEA,SAASQ,GAAWL,EAAkD,CACpE,OAAO,OAAOA,GAAU,UAC1B,CC/EA,IAAMQ,GAAa,OAAO,kBAAkB,EChB5C,IAAAC,EAAuB,SAIvB,IAAMC,GAAcC,EAAc,UAAU,KAAK,EAAE,SAAS,CAAC,IAAM,IAAA,IAC/DC,GAAQ,EAEZ,SAASC,GAAMC,EAAkC,CAC/C,GAAM,CAACC,EAAIC,CAAK,EAAU,WAA6BN,GAAW,CAAC,EAEnE,OAAAO,EAAgB,IAAM,CACfH,GAAiBE,EAAOE,GAAYA,GAAA,KAAAA,EAAW,OAAON,IAAO,CAAC,CACrE,EAAG,CAACE,CAAe,CAAC,EACbA,IAAoBC,EAAK,SAASA,CAAE,GAAK,GAClD",
  "names": ["composeEventHandlers", "originalEventHandler", "ourEventHandler", "checkForDefaultPrevented", "event", "React", "import_jsx_runtime", "createContext", "rootComponentName", "defaultContext", "Context", "Provider", "props", "children", "context", "value", "useContext", "consumerName", "createContextScope", "scopeName", "createContextScopeDeps", "defaultContexts", "BaseContext", "index", "scope", "_a", "createScope", "scopeContexts", "contexts", "composeContextScopes", "scopes", "baseScope", "scopeHooks", "overrideScopes", "nextScopes", "useScope", "currentScope", "React", "ReactDOM", "import_jsx_runtime", "NODES", "Primitive", "primitive", "node", "Slot", "createSlot", "Node", "props", "forwardedRef", "asChild", "primitiveProps", "Comp", "dispatchDiscreteCustomEvent", "target", "event", "React", "React", "useCallbackRef", "callback", "callbackRef", "args", "_a", "React", "useEscapeKeydown", "onEscapeKeyDownProp", "ownerDocument", "onEscapeKeyDown", "useCallbackRef", "handleKeyDown", "event", "import_jsx_runtime", "DISMISSABLE_LAYER_NAME", "CONTEXT_UPDATE", "POINTER_DOWN_OUTSIDE", "FOCUS_OUTSIDE", "originalBodyPointerEvents", "DismissableLayerContext", "DismissableLayer", "props", "forwardedRef", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "layerProps", "context", "node", "setNode", "ownerDocument", "_a", "force", "composedRefs", "useComposedRefs", "layers", "highestLayerWithOutsidePointerEventsDisabled", "highestLayerWithOutsidePointerEventsDisabledIndex", "index", "isBodyPointerEventsDisabled", "isPointerEventsEnabled", "pointerDownOutside", "usePointerDownOutside", "event", "target", "isPointerDownOnBranch", "branch", "focusOutside", "useFocusOutside", "useEscapeKeydown", "dispatchUpdate", "handleUpdate", "Primitive", "composeEventHandlers", "BRANCH_NAME", "DismissableLayerBranch", "ref", "handlePointerDownOutside", "useCallbackRef", "isPointerInsideReactTreeRef", "handleClickRef", "handlePointerDown", "handleAndDispatchPointerDownOutsideEvent", "handleAndDispatchCustomEvent", "eventDetail", "timerId", "handleFocusOutside", "isFocusInsideReactTreeRef", "handleFocus", "name", "handler", "detail", "discrete", "dispatchDiscreteCustomEvent", "Root", "Branch", "React", "import_react_dom", "React", "useLayoutEffect", "import_jsx_runtime", "PORTAL_NAME", "Portal", "props", "forwardedRef", "containerProp", "portalProps", "mounted", "setMounted", "useLayoutEffect2", "container", "_a", "ReactDOM", "Primitive", "React2", "React", "useStateMachine", "initialState", "machine", "state", "event", "nextState", "Presence", "props", "present", "children", "presence", "usePresence", "child", "ref", "useComposedRefs", "getElementRef", "node", "setNode", "stylesRef", "prevPresentRef", "prevAnimationNameRef", "send", "currentAnimationName", "getAnimationName", "useLayoutEffect2", "styles", "wasPresent", "prevAnimationName", "timeoutId", "ownerWindow", "_a", "handleAnimationEnd", "isCurrentAnimation", "currentFillMode", "handleAnimationStart", "element", "getter", "mayWarn", "_b", "React", "React2", "useInsertionEffect", "React", "useLayoutEffect2", "useControllableState", "prop", "defaultProp", "onChange", "caller", "uncontrolledProp", "setUncontrolledProp", "onChangeRef", "useUncontrolledState", "isControlled", "value", "isControlledRef", "wasControlled", "setValue", "nextValue", "isFunction", "_a", "prevValueRef", "SYNC_STATE", "React", "useReactId", "React", "count", "useId", "deterministicId", "id", "setId", "useLayoutEffect2", "reactId"]
}
